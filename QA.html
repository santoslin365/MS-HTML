<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>opeco - 引導模式</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        /* 繼承版本一經典視覺，並同步質感升級 */
        /* 繼承版本一經典視覺，並同步質感升級 */
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            background-color: #000;
            overflow: hidden;
            max-width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'PingFang TC', 'Microsoft JhengHei', sans-serif;
        }

        /* 背景容器：嚴格限制範圍 */
        .orb-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 0;
            pointer-events: none;
        }

        .orb {
            position: absolute;
            width: 600px;
            height: 600px;
            border-radius: 50%;
            filter: blur(120px);
            mix-blend-mode: screen;
            opacity: 0.5;
            will-change: transform;
        }

        .orb-1 {
            background: linear-gradient(45deg, #ff00ea, #00d2ff);
            top: -10%;
            left: -10%;
        }

        .orb-2 {
            background: linear-gradient(45deg, #00ff88, #ff0055);
            bottom: -10%;
            right: -10%;
        }

        .orb-3 {
            background: linear-gradient(45deg, #ffcc00, #0066ff);
            top: 50%;
            left: 50%;
        }

        /* 呼吸燈效動畫 */
        @keyframes border-pulse {
            0% {
                border-color: rgba(0, 255, 136, 0.3);
                box-shadow: 0 0 15px rgba(0, 255, 136, 0.1);
            }

            50% {
                border-color: rgba(0, 255, 136, 0.8);
                box-shadow: 0 0 30px rgba(0, 255, 136, 0.4);
            }

            100% {
                border-color: rgba(0, 255, 136, 0.3);
                box-shadow: 0 0 15px rgba(0, 255, 136, 0.1);
            }
        }

        /* 回覆框：位於中央稍微偏下 */
        #ai-response {
            position: fixed;
            bottom: 15%;
            left: 50%;
            transform: translateX(-50%);

            /* 桌面版自適應寬度 */
            width: clamp(300px, 60vw, 800px);

            max-width: 90vw;
            max-height: 40vh;
            overflow-y: auto;

            /* Glassmorphism 2.0 */
            background: rgba(30, 30, 35, 0.75);
            backdrop-filter: blur(40px) saturate(150%);
            -webkit-backdrop-filter: blur(40px) saturate(150%);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-top: 1px solid rgba(255, 255, 255, 0.25);

            padding: 40px 50px;
            border-radius: 32px;
            color: #eee;
            font-size: 1.25rem;
            /* 字體稍微加大 */
            line-height: 1.8;
            letter-spacing: 0.05em;

            z-index: 100;
            opacity: 0;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        /* 處理中狀態 */
        #ai-response.processing {
            animation: border-pulse 2s infinite ease-in-out;
            background: rgba(30, 30, 35, 0.85);
        }

        /* 輸入對話框 */
        #input-dialog {
            position: fixed;
            bottom: 5%;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 20px;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);

            /* 桌面版自適應寬度 */
            width: auto;
            min-width: 320px;
            max-width: 90vw;
        }

        #input-dialog input {
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: white;
            outline: none;

            /* 輸入框內容自適應 */
            width: clamp(280px, 30vw, 400px);

            font-size: 16px;
            text-align: center;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }

        #input-dialog input:focus {
            background: rgba(0, 0, 0, 0.6);
            border-color: rgba(0, 210, 255, 0.6);
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.2);
        }

        /* --- 手機版 RWD 適配 --- */
        @media (max-width: 768px) {
            #ai-response {
                width: 80%;
                /* 收窄寬度，增加左右留白 */
                padding: 25px 30px;
                font-size: 1.1rem;
                bottom: 20%;
            }

            #input-dialog {
                width: 85%;
                bottom: 5%;
                /* 手機鍵盤彈出時可能會被推上去，這裡保持固定 */
            }

            #input-dialog input {
                width: 100%;
                /* 填滿容器 */
                box-sizing: border-box;
            }
        }

        /* 捲軸樣式優化 */
        #ai-response::-webkit-scrollbar {
            width: 6px;
        }

        #ai-response::-webkit-scrollbar-track {
            background: transparent;
        }

        #ai-response::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }

        #ai-response::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        /* 按鈕樣式 */
        .action-btn {
            display: inline-block;
            margin-top: 30px;
            padding: 12px 40px;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.5);
            color: #00ff88;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            letter-spacing: 2px;
            text-shadow: 0 0 5px rgba(0, 255, 136, 0.5);
        }

        .action-btn:hover {
            background: rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.6);
            transform: scale(1.05);
            color: #fff;
            border-color: #fff;
        }
    </style>
</head>

<body>

    <div class="orb-container">
        <div class="orb orb-1"></div>
        <div class="orb orb-2"></div>
        <div class="orb orb-3"></div>
    </div>

    <div id="ai-response">
        <div id="ai-text"></div>
    </div>

    <div id="input-dialog">
        <input type="text" placeholder="回答 opeco..." id="main-input">
    </div>

    <script>
        // --- 基本配置 ---
        const KEY = "AIzaSyDTkt4b4yedqFuSiqwtWlyxZiIof2m68Sc";
        const MODEL = "gemini-3-flash-preview";

        // 從 sessionStorage 讀取繼承的資料
        const savedHistory = sessionStorage.getItem('opeco_history');
        const savedSystemPrompt = sessionStorage.getItem('opeco_system');

        let chatHistory = savedHistory ? JSON.parse(savedHistory) : [];
        let systemPrompt = savedSystemPrompt || "";

        const aiResponseDiv = document.querySelector('#ai-response');
        const aiText = document.querySelector('#ai-text');
        const inputDialog = document.querySelector('#input-dialog');
        const mainInput = document.querySelector('#main-input');

        let orbSpeed = 1;

        // 1. 背景光圈動畫 (版本一)
        document.querySelectorAll('.orb').forEach((orb, i) => {
            const move = () => { gsap.to(orb, { x: (Math.random() - 0.5) * window.innerWidth, y: (Math.random() - 0.5) * window.innerHeight, duration: (7 + i * 3) / orbSpeed, ease: "sine.inOut", onComplete: move }); };
            move();
        });

        // 2. 打字機效果 (升級版：支援 HTML 換行)
        function typeWriter(text, callback) {
            let i = 0;
            aiText.innerHTML = "";

            // 確保顯示
            gsap.to(aiResponseDiv, { opacity: 1, y: 0, duration: 0.5 });

            const interval = setInterval(() => {
                if (i < text.length) {
                    const char = text.charAt(i);
                    aiText.innerHTML += (char === '\n' ? '<br>' : char);
                    i++;
                    aiResponseDiv.scrollTop = aiResponseDiv.scrollHeight;
                } else {
                    clearInterval(interval);
                    if (callback) callback();
                }
            }, 30);
        }

        // 3. API 呼叫邏輯 (繼承自 index.html)
        async function callGemini(userMessage) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL}:generateContent?key=${KEY}`;

            const contents = [
                ...chatHistory,
                { role: "user", parts: [{ text: userMessage }] }
            ];

            const payload = {
                contents: contents,
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    temperature: 0.88,
                    maxOutputTokens: 4096
                }
            };

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                if (data.error) throw new Error(data.error.message);

                const aiResponse = data.candidates[0].content.parts[0].text;

                chatHistory.push({ role: "user", parts: [{ text: userMessage }] });
                chatHistory.push({ role: "model", parts: [{ text: aiResponse }] });

                return aiResponse;

            } catch (error) {
                console.error("API Error:", error);
                return `(系統警報) 連線中斷...錯誤訊息：${error.message}`;
            }
        }

        // 4. 流程啟動
        // 題目資料庫
        const qaQuestions = [
            {
                title: "題目 1：【酒館的破冰者】",
                context: "你推開神祕酒館『星火屋』的大門，裡面正進行著熱鬧的慶祝，有人在跳舞，有人在爭論。你會如何安置自己？",
                focus: "側重：主動性與觀察力"
            },
            {
                title: "題目 2：【迷霧中的分岔路】",
                context: "你來到了一片終年不散的迷霧森林，眼前出現了三條路：一條佈滿荊棘但有金光閃爍，一條開滿奇異花朵且芬芳撲鼻，一條則是平整卻看不到盡頭的石路。你會？",
                focus: "側重：行動動機"
            },
            {
                title: "題目 3：【許願池的倒影】",
                context: "你來到傳說中能映照靈魂的『真理之泉』，泉水告訴你，只要你願意投入一顆代表你靈魂的晶石，它能讓你立刻獲得一個永恆的恩賜。你最希望那是？",
                focus: "側重：生命核心追求"
            }
        ];

        let currentQIndex = 0;
        let totalScore = 0;

        window.onload = async () => {
            // 淡入效果
            gsap.from("body", { opacity: 0, duration: 1 });

            // 1. 播放開場白
            typeWriter("接下來要進入個性分析的環節...", () => {
                // 顯示開始按鈕
                const btn = document.createElement('div');
                btn.className = 'action-btn';
                btn.innerText = '開始分析';
                btn.onclick = () => {
                    // 按下後淡出按鈕
                    gsap.to(btn, {
                        opacity: 0, scale: 0.8, duration: 0.3, onComplete: () => {
                            btn.remove();
                            // 2. 開始第一題
                            startQuestion(0);
                        }
                    });
                };

                aiText.appendChild(document.createElement('br'));
                aiText.appendChild(btn);

                // 按鈕淡入動畫
                gsap.from(btn, { opacity: 0, y: 20, duration: 0.8, ease: "back.out(1.7)" });
            });
        };

        function startQuestion(index) {
            const q = qaQuestions[index];

            // 組合題目文字
            const questionHtml = `
                <div style="font-weight:bold; color:#00d2ff; margin-bottom:10px;">${q.title}</div>
                <div style="margin-bottom:10px;">${q.context}</div>
                <div style="font-size:0.9em; color:#888;">(${q.focus})</div>
            `;

            // 直接顯示 HTML 而非打字機效果，避免標籤外露
            aiText.innerHTML = questionHtml;
            gsap.fromTo(aiText, { opacity: 0, y: 10 }, { opacity: 1, y: 0, duration: 1 });

            // 顯示輸入框
            setTimeout(() => {
                showInput();
            }, 1000);
        }

        function showInput() {
            inputDialog.style.display = 'block';
            mainInput.disabled = false; // 關鍵修正：確保輸入框重新啟用
            mainInput.focus();
            gsap.fromTo(inputDialog, { opacity: 0, y: 20 }, { opacity: 1, y: 0, duration: 0.5 });
        }

        // 5. 處理回答
        mainInput.addEventListener("keydown", async (e) => {
            if (e.key === "Enter" && mainInput.value) {
                const userAns = mainInput.value;
                mainInput.value = "";
                mainInput.disabled = true;

                // 隱藏輸入框
                gsap.to(inputDialog, { opacity: 0, y: 20, onComplete: () => inputDialog.style.display = 'none' });

                // 顯示思考中
                aiResponseDiv.classList.add('processing'); // 啟動呼吸燈效
                aiText.innerHTML = "<span style='opacity:0.8; color:#00ff88; animation: pulse 0.5s infinite'>嗶嗶，資料掃描分析中...</span>";

                // 準備給 AI 的指令：評分 + 短評 (帶入 Opeco 人設)
                const q = qaQuestions[currentQIndex];

                // 明確告訴 AI 只要輸出分數，不要寫評語
                // 加入 JSON 強制指令與評分標準：相關性高=高分，無關=低分
                const nextInstruction = `(系統指令：使用者回答了第 ${currentQIndex + 1} 題：『${userAns}』。題目：『${q.context}』。
                
                請扮演 歐佩可 (Opeco)，針對使用者的回答給予：
                1. 評分 (1-10分)：依據回答的創意與相關性，越有趣越高分。
                2. 短評 (60字內)：用歐佩可的語氣 (有點毒舌但又可愛)，針對這個回答進行「反應+分析」。先對玩家的選擇表示驚訝或諷刺，接著給出一句看似看穿靈魂的心理分析。
                **注意：短評中絕對不要出現分數數字，保持神祕感。**

                請 **務必** 僅輸出標準 JSON 格式，不要有Markdown標記，格式如下：
                {"score": 數字, "comment": "簡短評語"}
                )`;

                // 呼叫 API 進行評分
                // 呼叫 API 進行評分
                try {
                    let rawResponse = await callGemini(nextInstruction);
                    console.log("Raw AI Response:", rawResponse);

                    let result = null;

                    // --- 防護一：強力外科手術式讀取 (Regex Parsing) ---
                    // 尋找字串中第一個及最後一個大括號，嘗試抓出 JSON 物件
                    const jsonMatch = rawResponse.match(/\{[\s\S]*\}/);

                    if (jsonMatch) {
                        try {
                            result = JSON.parse(jsonMatch[0]);
                        } catch (e) {
                            console.warn("Regex found something like JSON but parse failed:", e);
                        }
                    }

                    // 停止呼吸燈效
                    aiResponseDiv.classList.remove('processing');

                    if (result && typeof result.score === 'number') {
                        // --- 成功讀取 ---
                        const score = result.score;
                        const comment = result.comment || "收到！已記錄數據。"; // 保底評論
                        totalScore += score;
                        console.log(`Question ${currentQIndex + 1} Score: ${score}, Total: ${totalScore}`);

                        // --- 互動環節：顯示 AI 評論 ---
                        typeWriter(comment, () => {
                            // 顯示「下一題」按鈕
                            showNextButton();
                        });
                    } else {
                        throw new Error("JSON parsing failed or no score found");
                    }

                } catch (e) {
                    console.error("Scoring failed (Fallback triggered):", e);
                    // 停止呼吸燈效 (防呆)
                    aiResponseDiv.classList.remove('processing');

                    // --- 防護二 & 三：隨機波動 + 字數同情分保底 ---
                    // 根據使用者回答長度決定保底分段
                    // 字數多 (>5字) -> 保底 5~8 分
                    // 字數少 (<=5字) -> 保底 3~6 分
                    // 這樣就算 AI 壞掉，看起來也不會都是 5 分，而且感覺好像真的有在看你寫多寫少

                    const len = userAns.length;
                    let baseScore = 0;

                    if (len > 5) {
                        // 隨機 5, 6, 7, 8
                        baseScore = Math.floor(Math.random() * 4) + 5;
                    } else {
                        // 隨機 3, 4, 5, 6
                        baseScore = Math.floor(Math.random() * 4) + 3;
                    }

                    console.warn(`Fallback Score Applied: ${baseScore} (User Input Length: ${len})`);
                    totalScore += baseScore;

                    // 保底評論
                    const fallbackComments = [
                        "嗯...這回答很有你的風格呢！",
                        "收到！數據有點波動，但我記錄下來了。",
                        "哦？真是令人意外的答案。",
                        "嗶嗶...資料存檔完畢！"
                    ];
                    const randomComment = fallbackComments[Math.floor(Math.random() * fallbackComments.length)];

                    typeWriter(randomComment, () => {
                        showNextButton();
                    });
                }


            }
        });

        function showNextButton() {
            const btn = document.createElement('div');
            btn.className = 'action-btn';
            btn.innerText = (currentQIndex < qaQuestions.length - 1) ? '下一題' : '查看結果';
            btn.style.marginTop = '20px'; // 確保間距

            btn.onclick = () => {
                // 淡出按鈕
                gsap.to(btn, { opacity: 0, scale: 0.8, duration: 0.3, onComplete: () => btn.remove() });

                // 進入下一題邏輯
                currentQIndex++;
                if (currentQIndex < qaQuestions.length) {
                    // 淡出舊文字再換新題目
                    gsap.to(aiText, {
                        opacity: 0, y: -10, duration: 0.5, onComplete: () => {
                            startQuestion(currentQIndex);
                        }
                    });
                } else {
                    finishQuiz();
                }
            };

            aiText.appendChild(document.createElement('br'));
            aiText.appendChild(btn);
            gsap.from(btn, { opacity: 0, y: 10, duration: 0.5 });
        }

        function finishQuiz() {
            // 顯示結束語
            aiText.innerHTML = "<span style='opacity:0.8; color:#00ff88; animation: pulse 0.5s infinite'>測驗結束，正在生成靈魂頻譜...</span>";

            // 儲存總分
            sessionStorage.setItem('opeco_total_score', totalScore);

            setTimeout(() => {
                gsap.to("body", {
                    opacity: 0, duration: 2, onComplete: () => {
                        window.location.href = 'print.html';
                    }
                });
            }, 3000);
        }
    </script>
</body>

</html>